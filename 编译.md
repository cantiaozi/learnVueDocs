## 一、编译入口

组件调用$mount方法进行渲染，该方法定义在entry-runtime-with-compiler.js文件中，该方法中，调用了compileToFunctions方法将template模板编译成render函数。

```javascript
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  ......
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

compileToFunctions函数是执行函数createCompiler并传入baseOptions生成的。

```JavaScript
const { compile, compileToFunctions } = createCompiler(baseOptions)
```

经过多次转换，最终compileToFunctions是在compiler/to-function.js中定义的。

```JavaScript
function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    //调用extend方法将options中的所有属性值复制一份
    //放到空对象上，再将这个空对象赋给options
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1')
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          )
        }
      }
    }

    // check cache
    //编译的缓存
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // compile
    const compiled = compile(template, options)

    // check compilation errors/tips
    //对编译产生的错误和提示进行处理
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn(
          `Error compiling template:\n\n${template}\n\n` +
          compiled.errors.map(e => `- ${e}`).join('\n') + '\n',
          vm
        )
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(msg => tip(msg, vm))
      }
    }

    // turn code into functions
    const res = {}
    const fnGenErrors = []
    //编译产物中的render是字符串，调用createFunction将
    //字符串转换成函数
    //createFunction函数就是调用new Function将字符串
    //转换为函数
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(code => {
      return createFunction(code, fnGenErrors)
    })

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn(
          `Failed to generate render function:\n\n` +
          fnGenErrors.map(({ err, code }) => `${err.toString()} in\n\n${code}\n`).join('\n'),
          vm
        )
      }
    }
	//最后将结果保存在缓存中
    return (cache[key] = res)
}

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err, code })
    return noop
  }
}
```

compileToFunctions函数中最核心的部分是调用函数compile将template模板编译成render（字符串形式的render）。compile函数定义在compiler/create-compiler.js中。compile函数的核心是调用baseCompile函数编译生成render。

```JavaScript
function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      //baseOptions定义在platforms/web/compiler/options.js中
      //将baseOptions和options合并，最终保存在finalOptions上。
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []
      finalOptions.warn = (msg, tip) => {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        // copy other options
        for (const key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key]
          }
        }
      }
	  //执行baseCompile方法进行编译
      const compiled = baseCompile(template, finalOptions)
      if (process.env.NODE_ENV !== 'production') {
        errors.push.apply(errors, detectErrors(compiled.ast))
      }
      compiled.errors = errors
      compiled.tips = tips
      return compiled
}

export const baseOptions: CompilerOptions = {
  expectHTML: true,
  modules,
  directives,
  isPreTag,
  isUnaryTag,
  mustUseProp,
  canBeLeftOpenTag,
  isReservedTag,
  getTagNamespace,
  staticKeys: genStaticKeys(modules)
}
```

baseCompile定义在compiler/index.js中。parse方法传入template转化为ast语法树。

```JavaScript
function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
```

## 二、parse

parse方法如下，其中主要就是调用parseHTML方法解析template模板，最后返回root根ast节点。

```JavaScript
export function parse (
  template: string,
  options: CompilerOptions
): ASTElement | void {
  warn = options.warn || baseWarn

  platformIsPreTag = options.isPreTag || no
  platformMustUseProp = options.mustUseProp || no
  platformGetTagNamespace = options.getTagNamespace || no

  transforms = pluckModuleFunction(options.modules, 'transformNode')
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode')
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode')

  delimiters = options.delimiters

  const stack = []
  const preserveWhitespace = options.preserveWhitespace !== false
  let root
  let currentParent
  let inVPre = false
  let inPre = false
  let warned = false

  function warnOnce (msg) {
    if (!warned) {
      warned = true
      warn(msg)
    }
  }

  function closeElement (element) {
    // check pre state
    if (element.pre) {
      inVPre = false
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false
    }
    // apply post-transforms
    for (let i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options)
    }
  }

  //调用parseHTML方法解析template模板
  parseHTML(template, {
    warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag)

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs)
      }

      let element: ASTElement = createASTElement(tag, attrs, currentParent)
      if (ns) {
        element.ns = ns
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true
        process.env.NODE_ENV !== 'production' && warn(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          `<${tag}>` + ', as they will not be parsed.'
        )
      }

      // apply pre-transforms
      for (let i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element
      }

      if (!inVPre) {
        processPre(element)
        if (element.pre) {
          inVPre = true
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true
      }
      if (inVPre) {
        processRawAttrs(element)
      } else if (!element.processed) {
        // structural directives
        processFor(element)
        processIf(element)
        processOnce(element)
        // element-scope stuff
        processElement(element, options)
      }

      function checkRootConstraints (el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              `Cannot use <${el.tag}> as component root element because it may ` +
              'contain multiple nodes.'
            )
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            )
          }
        }
      }

      // tree management
      if (!root) {
        root = element
        checkRootConstraints(root)
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element)
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          })
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce(
            `Component template should contain exactly one root element. ` +
            `If you are using v-if on multiple elements, ` +
            `use v-else-if to chain them instead.`
          )
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent)
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false
          const name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
        } else {
          currentParent.children.push(element)
          element.parent = currentParent
        }
      }
      if (!unary) {
        currentParent = element
        stack.push(element)
      } else {
        closeElement(element)
      }
    },

    end () {
      // remove trailing whitespace
      const element = stack[stack.length - 1]
      const lastNode = element.children[element.children.length - 1]
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop()
      }
      // pop stack
      stack.length -= 1
      currentParent = stack[stack.length - 1]
      closeElement(element)
    },

    chars (text: string) {
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            )
          } else if ((text = text.trim())) {
            warnOnce(
              `text "${text}" outside root element will be ignored.`
            )
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      const children = currentParent.children
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : ''
      if (text) {
        let res
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text
          })
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text
          })
        }
      }
    },
    comment (text: string) {
      currentParent.children.push({
        type: 3,
        text,
        isComment: true
      })
    }
  })
  return root
}
```

parseHTML方法如下，其中通过调用options.start方法生成ast树。

```JavaScript
export function parseHTML (html, options) {
  const stack = []
  const expectHTML = options.expectHTML
  const isUnaryTag = options.isUnaryTag || no
  const canBeLeftOpenTag = options.canBeLeftOpenTag || no
  let index = 0
  let last, lastTag
  while (html) {
    last = html
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      let textEnd = html.indexOf('<')
      if (textEnd === 0) {
        // Comment:
        //是注释节点
        if (comment.test(html)) {
          const commentEnd = html.indexOf('-->')

          if (commentEnd >= 0) {
            //如果要保留注释节点，options.comment会创建一个注释节点的ast
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd))
            }
            advance(commentEnd + 3)
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        ////如果是conditionalComment节点，直接将要解析的字符串前进
        if (conditionalComment.test(html)) {
          const conditionalEnd = html.indexOf(']>')

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2)
            continue
          }
        }

        // Doctype:
        //如果是doctype节点，直接将要解析的字符串前进
        const doctypeMatch = html.match(doctype)
        if (doctypeMatch) {
          advance(doctypeMatch[0].length)
          continue
        }

        // End tag:
        //匹配结束标签
        const endTagMatch = html.match(endTag)
        if (endTagMatch) {
          const curIndex = index
          advance(endTagMatch[0].length)
          parseEndTag(endTagMatch[1], curIndex, index)
          continue
        }

        // Start tag:
        //匹配开始标签，获得标签名，属性等
        const startTagMatch = parseStartTag()
        if (startTagMatch) {
          //对标签名、属性等进行处理
          handleStartTag(startTagMatch)
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1)
          }
          continue
        }
      }

      let text, rest, next
      //处理标签中文本的逻辑
      if (textEnd >= 0) {
        rest = html.slice(textEnd)
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          //当文本中包含<的时候，需要前进找到真正的结束标签的左<号
          next = rest.indexOf('<', 1)
          if (next < 0) break
          textEnd += next
          rest = html.slice(textEnd)
        }
        text = html.substring(0, textEnd)
        advance(textEnd)
      }

      if (textEnd < 0) {
        text = html
        html = ''
      }

      if (options.chars && text) {
        options.chars(text)
      }
    } else {
      let endTagLength = 0
      const stackedTag = lastTag.toLowerCase()
      const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'))
      const rest = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1')
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1)
        }
        if (options.chars) {
          options.chars(text)
        }
        return ''
      })
      index += html.length - rest.length
      html = rest
      parseEndTag(stackedTag, index - endTagLength, index)
    }

    if (html === last) {
      options.chars && options.chars(html)
      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
        options.warn(`Mal-formatted tag at end of template: "${html}"`)
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag()

  function advance (n) {
    index += n
    html = html.substring(n)
  }

  function parseStartTag () {
    const start = html.match(startTagOpen)
    if (start) {
      const match = {
        tagName: start[1],
        attrs: [],
        start: index
      }
      advance(start[0].length)
      let end, attr
      //匹配属性
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length)
        match.attrs.push(attr)
      }
      if (end) {
        match.unarySlash = end[1]
        advance(end[0].length)
        match.end = index
        return match
      }
    }
  }

  function handleStartTag (match) {
    const tagName = match.tagName
    const unarySlash = match.unarySlash

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag)
      }
      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
        parseEndTag(tagName)
      }
    }

    //判断是否是自闭合标签
    const unary = isUnaryTag(tagName) || !!unarySlash

    const l = match.attrs.length
    const attrs = new Array(l)
    for (let i = 0; i < l; i++) {
      const args = match.attrs[i]
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      //浏览器兼容性处理
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3] }
        if (args[4] === '') { delete args[4] }
        if (args[5] === '') { delete args[5] }
      }
      //获取属性值
      const value = args[3] || args[4] || args[5] || ''
      //可能有转译，需要解码
      const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
      lastTag = tagName
    }

    //调用options.start创建ast
    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end)
    }
  }

  function parseEndTag (tagName, start, end) {
    let pos, lowerCasedTagName
    if (start == null) start = index
    if (end == null) end = index

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase()
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      //在stack数组中，从后往前找，第一个找到的就是和结束标签相匹配的开始标签
      //stack数组中，下标为pos到结束位置这之间的所有开始标签都不合法，没有匹配的结束标签
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (let i = stack.length - 1; i >= pos; i--) {
        if (process.env.NODE_ENV !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            `tag <${stack[i].tag}> has no matching end tag.`
          )
        }
        if (options.end) {
          options.end(stack[i].tag, start, end)
        }
      }

      // Remove the open elements from the stack
      stack.length = pos
      lastTag = pos && stack[pos - 1].tag
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end)
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end)
      }
      if (options.end) {
        options.end(tagName, start, end)
      }
    }
  }
}
```

options.start方法如下。该方法中调用createASTElement方法创建ast对象，传入的三个参数分别为标签名、属性和父ast对象。

```JavaScript
start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      //currentParent是父ast节点，用来构造树结构
      const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag)

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs)
      }
      //创建ast对象
      let element: ASTElement = createASTElement(tag, attrs, currentParent)
      if (ns) {
        element.ns = ns
      }
	  //判断是否是禁止的标签，例如script、style
      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true
        process.env.NODE_ENV !== 'production' && warn(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          `<${tag}>` + ', as they will not be parsed.'
        )
      }

      // apply pre-transforms
      //preTransforms是options的modules中所有preTransformNode对象组成的数组
      //preTransforms数组中的值都是一个方法
      for (let i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element
      }

      if (!inVPre) {
        processPre(element)
        if (element.pre) {
          inVPre = true
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true
      }
      if (inVPre) {
        processRawAttrs(element)
      } else if (!element.processed) {
        // structural directives
        //删除ast节点中attrsList中的v-for属性
        processFor(element)
        processIf(element)
        processOnce(element)
        // element-scope stuff
        //对ref、slot、component、事件等剩余属性进行处理
        processElement(element, options)
      }

      function checkRootConstraints (el) {
        if (process.env.NODE_ENV !== 'production') {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              `Cannot use <${el.tag}> as component root element because it may ` +
              'contain multiple nodes.'
            )
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            )
          }
        }
      }

      // tree management
      if (!root) {
        root = element
        //对根节点进行检查
        checkRootConstraints(root)
      } else if (!stack.length) {//stack数组不为空的情况，代表不止一个根节点
        // allow root elements with v-if, v-else-if and v-else
        //允许不止一个根节点的情况，即v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element)
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          })
        } else if (process.env.NODE_ENV !== 'production') {
          warnOnce(
            `Component template should contain exactly one root element. ` +
            `If you are using v-if on multiple elements, ` +
            `use v-else-if to chain them instead.`
          )
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent)
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false
          const name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
        } else {
          //当存在currentParent节点的时候，管理树的父子关系
          currentParent.children.push(element)
          element.parent = currentParent
        }
      }
      //非自闭合节点的情况
      if (!unary) {
        currentParent = element
        stack.push(element)
      } else {
        closeElement(element)
      }
},
    
    
export function createASTElement (
  tag: string,
  attrs: Array<Attr>,
  parent: ASTElement | void
): ASTElement {
  return {
    type: 1,//ast节点类型，1为元素ast节点
    tag,
    attrsList: attrs,
    //调用makeAttrsMap方法将attrs数组转化为对象
    attrsMap: makeAttrsMap(attrs),
    parent,
    children: []
  }
}

export function processFor (el: ASTElement) {
  let exp
  //删除ast节点中attr属性中v-for属性并返回该属性的值
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    const res = parseFor(exp)
    if (res) {
      //将v-for的值解析出来扩展到ast节点上
      extend(el, res)
    } else if (process.env.NODE_ENV !== 'production') {
      warn(
        `Invalid v-for expression: ${exp}`
      )
    }
  }
}

export function parseFor (exp: string): ?ForParseResult {
  //匹配v-for的值，例如(item, index) in arrs
  const inMatch = exp.match(forAliasRE)
  if (!inMatch) return
  const res = {}
  //拿到arrs
  res.for = inMatch[2].trim()
  const alias = inMatch[1].trim().replace(stripParensRE, '')
  const iteratorMatch = alias.match(forIteratorRE)
  if (iteratorMatch) {
    //拿到item
    res.alias = alias.replace(forIteratorRE, '')
    //拿到index
    res.iterator1 = iteratorMatch[1].trim()
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim()
    }
  } else {
    res.alias = alias
  }
  return res
}

function processIf (el) {
  //删除ast节点中attr属性中v-if属性并返回该属性的值
  const exp = getAndRemoveAttr(el, 'v-if')
  if (exp) {
    el.if = exp
    addIfCondition(el, {
      exp: exp,
      block: el
    })
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true
    }
    const elseif = getAndRemoveAttr(el, 'v-else-if')
    if (elseif) {
      el.elseif = elseif
    }
  }
}
```

options.end方法如下

```JavaScript
end () {
      // remove trailing whitespace
      const element = stack[stack.length - 1]
      const lastNode = element.children[element.children.length - 1]
      //对文本的处理
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop()
      }
      // pop stack
      stack.length -= 1
      currentParent = stack[stack.length - 1]
      closeElement(element)
},
```

vue中通过栈这样的数据结构对ast节点进行树结构的管理。在解析开始前，定义一个变量currentParent指向每次生成ast节点过程中的父节点，每次生成ast对象的时候，**currentParent.children.push(element)**、**element.parent = currentParent**确定好父子关系。当在parse解析template的过程中，匹配到开始标签的话，会调用start方法生成一个ast节点并确定父子关系后，会将该节点push到stack数组中，并且将currentParent指向该节点（只有该节点对应的标签是非自闭合标签，才会push到stack数组中，并重新指定currentParent）；当匹配到结束标签的时候，会调用end方法，在该方法中，将stack数组最后一位拿掉，并且将currentParent指向此时stack数组的最后一位。

例子：

```html
<div id="app">
    <span></span>
</div>
```

1.parse解析template，首次匹配到开始标签div，生成ast对象R，将其设置为根节点，此时currentParent不存在，stack数组为空，将currentParent指向R，并将R给push到stack数组中。

2.匹配到span的开始标签，生成ast对象s，此时currentParent指向R，因此s的父节点是R，R的子节点之一是s。然后将currentParent指向s，并将s给push到stack数组中。

3.匹配到span的结束标签，将stack数组的最后一位给拿掉，此时数组中只有一个值，即R，将currentParent指向stack数组最后一位，即R。

4.匹配到div的结束标签，将stack数组的最后一位给拿掉，此时数组为空，将currentParent指向stack数组最后一位，即空。

当在解析过程中，匹配到文本的时候，会调用chars方法。

```JavaScript
chars (text: string) {
      //对不合法的文本进行判断
      if (!currentParent) {
        if (process.env.NODE_ENV !== 'production') {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            )
          } else if ((text = text.trim())) {
            warnOnce(
              `text "${text}" outside root element will be ignored.`
            )
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      const children = currentParent.children
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : ''
      if (text) {
        let res
        //当不是在vPre环境下，且text不为空格的时候，调用parseText解析文本
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          children.push({
            type: 2,//type为2可以理解为表达式ast节点
            expression: res.expression,
            tokens: res.tokens,
            text
          })
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,//type为3是纯文本或者注释的ast节点
            text
          })
        }
      }
}
```

一下面的template为例，详细说一下解析的过程：

```JavaScript
let app = new Vue({
    el: '#app',
    template: '<ul :class="bindCls" class="list" v-if="isShow">' + 
        '<li v-for="(item, index) in data" @click="clickItem(index)">{{item}}:<{{index}}</li>' + 
        '</ul>',
    data: {
        bindCls: 'a',
        isShow: true,
        data: ['A', 'B', 'C', 'D']
    },
    methods: {
        clickItem(index) {
            console.log(index)
        }
    }
})
```

循环template字符串模板，找到“<”号，如果 “<”号 位置是0的话，说明解析到标签。如果大于0，说明解析到文本。当标签是自定义的组件的时候和html原始标签一样。

1.第一次循环， “<”号位置是0，匹配到开始标签ul，处理开始标签，拿到ul中的属性，调用start方法，生成ast对象并做处理，然后管理树结构，最后template模板字符串前进。

2.第二次循环，字符串是'<li v-for="(item, index) in data" @click="clickItem(index)">{{item}}:<{{index}}</li>' + 
        '</ul>'， “<”号位置是0，匹配到开始标签li，处理开始标签，拿到li中的属性，调用start方法，生成ast对象并做处理，然后管理树结构，最后template模板字符串前进。

3.第三次循环，字符串是{{item}}:<{{index}}</li>' + 
        '</ul>'， “<”号位置大于0，匹配到文本，调用chars方法处理文本，生成ast对象，然后管理树结构，最后template模板字符串前进。

4.第四次循环，字符串是</li>' + 
        '</ul>'， “<”号位置是0，匹配到结束标签/li，根据stack数组判断标签是否闭合，然后调用end方法，将管理ast节点树结构的stack数组最后一位拿掉，给currentParent赋值，最后更新判断标签是否闭合的stack数组。

5.第五次循环，字符串是'</ul>'，匹配到结束标签/ul，此步做的处理内容合上一步类似。最后，清空stack数组，字符串模板为空。

注意点：当在模板中这么写标签的时候

```html
<p>111<div>222</div></p>
```

会被解析成这样

```html
<p>111</p><div>222</div><p></p>
```

因为p标签中不能包含div标签，这是和html保持一致的。当p标签中嵌套p标签的时候，也是一样的处理。

## 三、optimise

当我们的模板 `template` 经过 `parse` 过程后，会输出生成 AST 树，那么接下来我们需要对这颗树做优化，即`optimize` 。

为什么要有优化过程，因为我们知道 Vue 是数据驱动，是响应式的，但是我们的模板并不是所有数据都是响应式的，也有很多数据是首次渲染后就永远不会变化的，那么这部分数据生成的 DOM 也不会变化，我们可以在 `patch` 的过程跳过对他们的比对。optimise就是要将这些不会变化的ast节点标记出来。

```JavaScript
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  isStaticKey = genStaticKeysCached(options.staticKeys || '')
  isPlatformReservedTag = options.isReservedTag || no
  // first pass: mark all non-static nodes.
  markStatic(root)
  // second pass: mark static roots.
  markStaticRoots(root, false)
}
```

optimize方法干了两件事，一是标记静态节点，二是标记静态根。

标记为静态节点的方法markStatic

```JavaScript
function markStatic (node: ASTNode) {
  node.static = isStatic(node)
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {j
      return
    }
    //遍历子节点判断是否是静态的
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i]
      markStatic(child)
      //当一个ast节点的其中一个子节点不是静态结点的时候，那么这个ast节点也不是静态的
      if (!child.static) {
        node.static = false
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
          node.static = false
        }
      }
    }
  }
}

function isStatic (node: ASTNode): boolean {
  if (node.type === 2) { // expression表达式ast节点
    return false
  }
  if (node.type === 3) { // text文本或者注释ast节点
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings 没有绑定值v-bind
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in不是内置组件例如keepAlive
    isPlatformReservedTag(node.tag) && // not a component不是自定义组件
    !isDirectChildOfTemplateFor(node) &&//不能是v-for标签下面的直接子节点
    Object.keys(node).every(isStaticKey)
    //判断ast节点上的属性是否是attrs、attrsList、attrsMap、children、parent、plain、staticClass
    //staticStyle、tag、type这些静态属性
  ))
}
```

标记为静态根的方法markStaticRoots

```JavaScript
function markStaticRoots (node: ASTNode, isInFor: boolean) {
  //仅会对元素ast节点标记为静态根
  if (node.type === 1) {
    if (node.static || node.once) {
      //staticInFor表示节点上是否有v-for属性
      node.staticInFor = isInFor
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    //如果一个ast节点是静态的，且有子节点，并且不是仅仅只有一个文本子节点，那么就标记为静态根
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
    if (node.children) {
      for (let i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for)
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        markStaticRoots(node.ifConditions[i].block, isInFor)
      }
    }
  }
}
```

分析下面这样的例子

```JavaScript
import Vue from 'vue'
let app = new Vue({
    el: '#app',
    template: '<div><ul :class="bindCls" class="list" v-if="isShow">' + 
        '<li v-for="(item, index) in data" @click="clickItem(index)">{{item}}:<{{index}}</li>' + 
        '</ul>' + '<div><p>111</p></div><p>222</p></div>',
    data: {
        bindCls: 'a',
        isShow: true,
        data: ['A', 'B', 'C', 'D']
    },
    methods: {
        clickItem(index) {
            console.log(index)
        }
    }
})
```

首先看markStatic方法，第一次调用传入的是根ast节点，是静态节点；第二次调用传入的是ul节点，因为其上有非静态属性 classBinding 等，所以是非静态节点；第三次调用传入的是ul节点的子节点li节点，因为上面有 events 等属性，是非静态属性；第四次调用传入的是li节点的子节点文本节点，因为是表达式节点，故非静态节点。最后，上面四个节点都是非静态节点，其中根ast节点因为子节点ul是非静态节点，因此也是非静态节点。第五次传入的是根ast节点的子节点div节点，是静态节点，后面几次调用不在赘述。最终，根ast节点的第二个子节点div节点是静态结点，第三个子节点p节点也是静态结点。

再看markStaticRoots方法，第一次调用传入的是根ast节点，非静态节点，因此非静态根；第二次调用传入的是ul节点，该节点是非静态节点，所以非静态根；第三次调用传入的是li节点，该节点是非静态节点，所以非静态根；第四次调用传入的是li节点的子节点文本节点，节点类型是2，即表达式ast节点，故非静态根（上面根本没有staticRoot属性）；第五次传入的是根ast节点的子节点div节点，是静态节点，它有一个子节点，且子节点不是文本或者注释节点，因此是静态根。第六次传入的是根ast节点的子节点p节点，是静态节点，它有一个子节点，但是子节点是文本节点，因此非静态根。后续步骤不再赘述。

总结：optimize的目标是通过标记静态根的方式，优化重新渲染过程中对静态节点的处理逻辑。而标记静态节点是为了方便后面标记静态根。

## 四、codegen

codegen就是把优化后的 AST 树转换成可执行的代码（字符串形式）。

看下面的例子

```JavaScript
import Vue from '../node_modules/vue/dist/vue.esm'
new Vue({
    el: '#app',
    template: '<ul :class="bindCls" class="list" v-if="isShow">' + 
        '<li v-for="(item, index) in data" @click="clickItem(index)">{{item}}:<{{index}}</li>' + 
        '</ul>',
    data: {
        bindCls: 'a',
        isShow: true,
        data: ['A', 'B', 'C', 'D']
    },
    methods: {
        clickItem(index) {
            console.log(index)
        }
    }
})
```

它经过generate方法，生成的代码字符串如下：

```JavaScript
with(this){
  return (isShow) ?
    _c('ul', {
        staticClass: "list",
        class: bindCls
      },
      _l((data), function(item, index) {
        return _c('li', {
          on: {
            "click": function($event) {
              clickItem(index)
            }
          }
        },
        [_v(_s(item) + ":" + _s(index))])
      })
    ) : _e()
}
```

这里的 `_c` 函数定义在 `src/core/instance/render.js` 中。

```js
vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
```

而 `_l`、`_v` 定义在 `src/core/instance/render-helpers/index.js` 中：

```js
export function installRenderHelpers (target: any) {
  target._o = markOnce
  target._n = toNumber
  target._s = toString
  target._l = renderList
  target._t = renderSlot
  target._q = looseEqual
  target._i = looseIndexOf
  target._m = renderStatic
  target._f = resolveFilter
  target._k = checkKeyCodes
  target._b = bindObjectProps
  target._v = createTextVNode
  target._e = createEmptyVNode
  target._u = resolveScopedSlots
  target._g = bindObjectListeners
}
```

上面生成的代码字符串中， `_l` 对应 `renderList` 渲染列表；`_v` 对应 `createTextVNode` 创建文本 VNode；`_e` 对于 `createEmptyVNode`创建空的 VNode。

generate函数定义如下：

```JavaScript
export function generate (
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c("div")'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}

export class CodegenState {
  constructor (options: CompilerOptions) {
    this.options = options
    this.warn = options.warn || baseWarn
    this.transforms = pluckModuleFunction(options.modules, 'transformCode')
    //拿到platforms/web/compiler/modules文件夹下的各个模块中定义的genData函数
    //dataGenFns是一个数组
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData')
    this.directives = extend(extend({}, baseDirectives), options.directives)
    const isReservedTag = options.isReservedTag || no
    this.maybeComponent = (el: ASTElement) => !isReservedTag(el.tag)
    this.onceId = 0
    this.staticRenderFns = []
  }
}

export function genElement (el: ASTElement, state: CodegenState): string {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      //生成createElement方法中的data数据
      const data = el.plain ? undefined : genData(el, state)
	  //生成createElement方法中的children数据
      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
```

对于本文的例子来说，根ast节点上有v-if属性，因此走到genElement方法的时候，走的是genIf逻辑。

```JavaScript
export function genIf (
  el: any,
  state: CodegenState,
  altGen?: Function,
  altEmpty?: string
): string {
  el.ifProcessed = true // avoid recursion
  //el节点的ifConditions是一个数组，如图所示
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions: ASTIfConditions,
  state: CodegenState,
  altGen?: Function,
  altEmpty?: string
): string {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  const condition = conditions.shift()
  if (condition.exp) {
    //ast节点的conditions中的block指向的是ast节点本身
    return `(${condition.exp})?${
      genTernaryExp(condition.block)
    }:${
   	  //递归调用genIfConditions的时候，conditions已经称为了空数组，因此返回'_e()'
      genIfConditions(conditions, state, altGen, altEmpty)
    }`
  } else {
    return `${genTernaryExp(condition.block)}`
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    //形参altGen为undefined
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}
```

![](E:\开发文档\新建文件夹\learnVueDocs\others\codeGen中ifCondition.png)

在genIfConditions方法中，根ast节点上没有once属性，因此递归执行了genElement方法。再次执行genElement方法的时候，因为el.ifProcessed为true，因此不会执行genIf方法，而是执行genElement中的else中的逻辑。

else逻辑中会执行genData方法，该方法就是生成creatElement中的dom的data属性。在本例子中，因为state.dataGenFns存在，因此会走到这个for循环逻辑。

```JavaScript
export function genData (el: ASTElement, state: CodegenState): string {
  let data = '{'

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  const dirs = genDirectives(el, state)
  if (dirs) data += dirs + ','

  // key
  if (el.key) {
    data += `key:${el.key},`
  }
  // ref
  if (el.ref) {
    data += `ref:${el.ref},`
  }
  if (el.refInFor) {
    data += `refInFor:true,`
  }
  // pre
  if (el.pre) {
    data += `pre:true,`
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += `tag:"${el.tag}",`
  }
  // module data generation functions
  for (let i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el)
  }
  // attributes
  if (el.attrs) {
    data += `attrs:{${genProps(el.attrs)}},`
  }
  // DOM props
  if (el.props) {
    data += `domProps:{${genProps(el.props)}},`
  }
  // event handlers
  if (el.events) {
    data += `${genHandlers(el.events, false, state.warn)},`
  }
  if (el.nativeEvents) {
    data += `${genHandlers(el.nativeEvents, true, state.warn)},`
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += `slot:${el.slotTarget},`
  }
  // scoped slots
  if (el.scopedSlots) {
    data += `${genScopedSlots(el.scopedSlots, state)},`
  }
  // component v-model
  if (el.model) {
    data += `model:{value:${
      el.model.value
    },callback:${
      el.model.callback
    },expression:${
      el.model.expression
    }},`
  }
  // inline-template
  if (el.inlineTemplate) {
    const inlineTemplate = genInlineTemplate(el, state)
    if (inlineTemplate) {
      data += `${inlineTemplate},`
    }
  }
  data = data.replace(/,$/, '') + '}'
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data)
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data)
  }
  return data
}
```

state.dataGenFns数组中的两个genData函数分别为，因为根ast节点上有静态的类名和动态绑定的类名，因此会生成字符串`{staticClass:"list",class:bindCls,`。

```JavaScript
function genData (el: ASTElement): string {
  let data = ''
  if (el.staticClass) {
    data += `staticClass:${el.staticClass},`
  }
  if (el.classBinding) {
    data += `class:${el.classBinding},`
  }
  return data
}

function genData (el: ASTElement): string {
  let data = ''
  if (el.staticStyle) {
    data += `staticStyle:${el.staticStyle},`
  }
  if (el.styleBinding) {
    data += `style:(${el.styleBinding}),`
  }
  return data
}
```

genData方法中最后会给字符串加上`}`右大括号，最终返回字符串`{staticClass:"list",class:bindCls}`。

再看下genChildren方法，该方法生成createElement中dom的子节点。在本例中，根ast节点的子节点只有一个且有v-for属性，因此执行if中的逻辑再次调用genElement方法。

```JavaScript
export function genChildren (
  el: ASTElement,
  state: CodegenState,
  checkSkip?: boolean,
  altGenElement?: Function,
  altGenNode?: Function
): string | void {
  const children = el.children
  if (children.length) {
    const el: any = children[0]
    // optimize single v-for
    if (children.length === 1 &&
      el.for &&
      el.tag !== 'template' &&
      el.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el, state)
    }
    const normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0
    const gen = altGenNode || genNode
    return `[${children.map(c => gen(c, state)).join(',')}]${
      normalizationType ? `,${normalizationType}` : ''
    }`
  }
}
```

再次调用genElement方法，传入根ast节点的子节点li节点。在该方法中执行genFor方法。该方法最终生成的字符串是

```JavaScript
_l((data), function(item, index) {
        return _c('li', {
          on: {
            "click": function($event) {
              clickItem(index)
            }
          }
        },
        [_v(_s(item) + ":" + _s(index))])
})
```



```JavaScript
export function genFor (
  el: any,
  state: CodegenState,
  altGen?: Function,
  altHelper?: string
): string {
  const exp = el.for
  const alias = el.alias
  const iterator1 = el.iterator1 ? `,${el.iterator1}` : ''
  const iterator2 = el.iterator2 ? `,${el.iterator2}` : ''
  //节点没有key属性时进行警告
  if (process.env.NODE_ENV !== 'production' &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      `<${el.tag} v-for="${alias} in ${exp}">: component lists rendered with ` +
      `v-for should have explicit keys. ` +
      `See https://vuejs.org/guide/list.html#key for more info.`,
      true /* tip */
    )
  }

  el.forProcessed = true // avoid recursion
  return `${altHelper || '_l'}((${exp}),` +
    `function(${alias}${iterator1}${iterator2}){` +
      `return ${(altGen || genElement)(el, state)}` +
    '})'
}
```

genFor方法中又会再次调用genElement方法。genElement方法中，因为el.forProcessed为true，不会再执行genFor方法，而是执行else中的逻辑。首先执行genData方法，在genData方法中，因为li节点上定义了事件监听函数，因此会执行genHandlers方法。genHandlers生成的代码字符串是 `on:{"click":function($event){clickItem(index)}},`。然后执行genChildren方法。

```JavaScript
export function genHandlers (
  events: ASTElementHandlers,
  isNative: boolean,
  warn: Function
): string {
  let res = isNative ? 'nativeOn:{' : 'on:{'
  for (const name in events) {
    res += `"${name}":${genHandler(name, events[name])},`
  }
  return res.slice(0, -1) + '}'
}
```

在genChildren方法中，li节点的children数组只有一个值，是一个表达式节点，不满足if中的逻辑。后面因为checkSkip为true，所以会执行getNormalizationType，返回值为0，表示不需要normalization。最后会对子节点children数组中的每一项执行genNode方法。

```JavaScript
function genNode (node: ASTNode, state: CodegenState): string {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

export function genText (text: ASTText | ASTExpression): string {
  return `_v(${text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))
  })`
}
```

因为li节点的子节点是一个type为2，即表达式节点，因此genNode方法中又会执行genText方法。最终，li节点genChildren方法生成的代码字符为 `[_v(_s(item)+":"+_s(index))]`。

