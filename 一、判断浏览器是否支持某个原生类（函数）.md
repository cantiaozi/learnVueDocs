## 一.new Vue()发生了什么

Vue函数定义在src\core\instance目录下的index.js文件中。

```JavaScript
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

_init方法src\core\instance目录下的init.js文件中。挂载在Vue的原型对象上。

```javascript
Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
}
```

_init方法中进行了一些列初始化操作，将vue实例的配置放到实例的$options属性上。这里我们重点分析3个地方，initProxy(vm)、initState(vm)和$mount页面挂载方法。

### 1.1 initProxy(vm)

当我们在vue的template模板中使用了一个未定义的变量时，会报错提示。这是因为做了Proxy代理，当访问vue实例上的相应属性时，会通过这层代理。

![](E:\开发文档\新建文件夹\learnVueDocs\others\image-20210607191609302.png)

initProxy是这样定义的。

```JavaScript
function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      const options = vm.$options
      const handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler
      vm._renderProxy = new Proxy(vm, handlers)
    } else {
      vm._renderProxy = vm
    }
}
```

其中hasProxy判断浏览器是否支持原生的Proxy对象。hasHander的定义如下。在hasHander对象中拦截了`propKey in proxy`的操作。warnNonPresent方法就是报错提示的方法。

```JavaScript
const hasHandler = {
    has (target, key) {
      const has = key in target
      const isAllowed = allowedGlobals(key) || (typeof key === 'string' && key.charAt(0) === '_')
      if (!has && !isAllowed) {
        warnNonPresent(target, key)
      }
      return has || !isAllowed
    }
}
```

```JavaScript
const warnNonPresent = (target, key) => {
    warn(
      `Property or method "${key}" is not defined on the instance but ` +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    )
}
```

### 1.2 initState(vm)

我们在vue的某些生命周期中可以通过this.xxx的方式来访问data、props和methods中的属性。这是通过代理来实现的。initState函数的代码如下：

```JavaScript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

initState函数中主要是对props、methods、data、computed和watch属性进行初始化。initData方法的代码如下：

```JavaScript
function initData (vm: Component) {
  let data = vm.$options.data
  //data属性通常是一个函数，当是函数时，执行getData方法。
  //getData方法主要时执行了data函数，并将其函数内部的this绑定为vue实例。方法返回一个对象
  //之所以设计为函数，是因为组件可以复用，这样可以为每个组件实例生成一个data对象
  //避免修改一个组建的data属性，影响到另一个组件。
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  //while循环中判断data中的属性是否会和props和methods中的属性重复
  //因为props、data和methods中的属性都可以通过组件实例访问，需要避免重名。
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      //data属性放到了组件实例的_data属性上。  
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```

proxy方法中通过Object.defineProperty可以在组件实例上访问data中的属性。proxy方法如下：

```JavaScript
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

proxy传入的第二个参数是'_data'，当访问或者设置组件实例上的属性时，会去访问或者设置组件实例__data属性上的相应属性。

## 一、可复用的方法

1、判断浏览器是否支持某个原生类（函数）

```JavaScript
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}
```

