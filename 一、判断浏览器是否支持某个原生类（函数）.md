## 一.new Vue()发生了什么

Vue函数定义在src\core\instance目录下的index.js文件中。

```JavaScript
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

_init方法src\core\instance目录下的init.js文件中。挂载在Vue的原型对象上。

```javascript
Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    
    vm._uid = uid++

    let startTag, endTag
    
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    vm._isVue = true
    if (options && options._isComponent) {
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }

    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }

    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) 
    initState(vm)
    initProvide(vm) 
    callHook(vm, 'created')

    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
}
```

_init方法中进行了一些列初始化操作，将vue实例的配置放到实例的$options属性上。这里我们重点分析3个地方，initProxy(vm)、initState(vm)和$mount页面挂载方法。

### 1.1 initProxy(vm)

当我们在vue的template模板中使用了一个未定义的变量时，会报错提示。这是因为做了Proxy代理，当访问vue实例上的相应属性时，会通过这层代理。

![](E:\开发文档\新建文件夹\learnVueDocs\others\image-20210607191609302.png)

initProxy是这样定义的。

```JavaScript
function initProxy (vm) {
    if (hasProxy) {
      const options = vm.$options
      const handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler
      vm._renderProxy = new Proxy(vm, handlers)
    } else {
      vm._renderProxy = vm
    }
}
```

其中hasProxy判断浏览器是否支持原生的Proxy对象。hasHander的定义如下。在hasHander对象中拦截了`propKey in proxy`的操作。方法中定义了一个Proxy对象，并挂载vue实例的_renderProxy属性上。warnNonPresent方法就是报错提示的方法。

```JavaScript
const hasHandler = {
    has (target, key) {
      const has = key in target
      const isAllowed = allowedGlobals(key) || (typeof key === 'string' && key.charAt(0) === '_')
      if (!has && !isAllowed) {
        warnNonPresent(target, key)
      }
      return has || !isAllowed
    }
}
```

```JavaScript
const warnNonPresent = (target, key) => {
    warn(
      `Property or method "${key}" is not defined on the instance but ` +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    )
}
```

### 1.2 initState(vm)

我们在vue的某些生命周期中可以通过this.xxx的方式来访问data、props和methods中的属性。这是通过代理来实现的。initState函数的代码如下：

```JavaScript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

initState函数中主要是对props、methods、data、computed和watch属性进行初始化。initData方法的代码如下：

```JavaScript
function initData (vm: Component) {
  let data = vm.$options.data
  //data属性通常是一个函数，当是函数时，执行getData方法。
  //getData方法主要时执行了data函数，并将其函数内部的this绑定为vue实例。方法返回一个对象
  //之所以设计为函数，是因为组件可以复用，这样可以为每个组件实例生成一个data对象
  //避免修改一个组建的data属性，影响到另一个组件。
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  //while循环中判断data中的属性是否会和props和methods中的属性重复
  //因为props、data和methods中的属性都可以通过组件实例访问，需要避免重名。
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      //data属性放到了组件实例的_data属性上。  
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```

proxy方法中通过Object.defineProperty可以在组件实例上访问data中的属性。proxy方法如下：

```JavaScript
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

proxy传入的第二个参数是'_data'，当访问或者设置组件实例上的属性时，会去访问或者设置组件实例__data属性上的相应属性。

### 1.3 $mount方法

```JavaScript
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  //query方法就是返回el代表的dom对象。
  //如果传入的是string，通过document.querySelector找到页面上的dom对象并放回该对象
  //如果是Element，就直接返回
  el = el && query(el)

  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // vue中template或者el都会最终转换为render函数。如果render不存在，需要将
  // template或者el转换为render
  if (!options.render) {
    let template = options.template
    if (template) {
      //当vue实例中有template属性，且是字符串
      if (typeof template === 'string') {
        //字符串以#开头，代表id,template中也可以el属性那样写id
        if (template.charAt(0) === '#') {
          //idToTemplate方法实际上是调用query方法，获取dom对象，并且该方法中做了缓存。
          template = idToTemplate(template)
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      //template.nodeType存在，说明template是一个虚拟dom对象
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    //如果template不存在，el存在，就拿到el这个dom对象的outerHTML属性
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }
	  //将template转换为render函数，最终vue实例挂载是依赖render函数
      const { render, staticRenderFns } = compileToFunctions(template, {
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```

$mount方法的最后调用mount方法。mount方法如下：

```JavaScript
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}
```

mount方法中调用mountComponent方法并返回结果。mountComponent方法如下：

```JavaScript
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      //当实例中template或者el存在时，说明没有编译为render函数
      //提示当前版本为runtime-only版本
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  callHook(vm, 'beforeMount')

  let updateComponent
  //性能埋点相关，可以忽略，走else里的逻辑，定义updateComponent函数
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  //这里定义了一个watcher对象，watcher分为两类：一是vue实例中的自定义watch
  //二是render watcher即渲染watcher，这里就是渲染watcher。
  //noop是一个空函数，true代表这是一个渲染watcher
  //第四个参数时watcher对象的配置
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

Watcher的构造函数中与页面首次加载渲染相关的逻辑主要如下，首次渲染的时候就是执行updateComponent方法，该方法就是渲染整个页面。

```JavaScript
export default class Watcher {
	constructor(
    	vm: Component,
        expOrFn: string | Function,
        cb: Function,
        options?: ?Object,
        isRenderWatcher?: boolean
    ) {
		//如果是渲染watcher，将watcher实例挂到vue实例的_watcher属性上
		if (isRenderWatcher) {
          vm._watcher = this
        }
        this.getter = expOrFn
        //执行expOrFn函数
        this.value = this.get()
	}
	
	get () {
        let value
        const vm = this.vm
        value = this.getter.call(vm, vm)
        return value
  	}

}
```

### 1.4 _render方法

上面的updateComponent方法中调用了vue实例上的_render方法。 _render方法是在src\core\instance目录下的index.js文件中的renderMixin中定义的（详情请看1.1）。

```JavaScript
Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    .....
	//执行vm.$options中的render函数，传入两个参数
    //第一个参数vm._renderProxy是一个Proxy对象，详情查看1.1
    //vm.$createElement方法定义在initRender函数中
    //initRender函数在_init方法中被执行了
    let vnode
    try {
      //调用render函数,把render函数中的this绑定为Proxy对象。
      //当对不存在的属性进行in操作符时，或者在template模板中使用不存在的属性都会报错
      //执行render函数会生成vnode虚拟dom
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      ...
    }
    // 判断当vnode是一个数组时，进行报警。根节点只能有一个dom
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    vnode.parent = _parentVnode
    return vnode
  }
```

render函数在执行时，传入了$createElement方法，我们在vue中使用render一般如下所示，render函数中的h就是$createElement的形参。

```JavaScript
render(h) {
    return h('div', {
      attrs: {
        id: 'app1'
      }
    }, this.msg)
},
```

1.4 createElement方法

```JavaScript
vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
```

$createElement方法中执行createElement方法。

```JavaScript
const SIMPLE_NORMALIZE = 1
const ALWAYS_NORMALIZE = 2
//normalizationType一般是布尔值，当为true时，表示手写的render函数
//为false时，表示编译生成的render函数
export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  //当使用render函数时，data属性是可以不传的，这时候需要把后面的参数向前面移动一位
  //当data是数组或者基本类型的数据时，判断成data没传
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}

export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  ...
    
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```



## 一、可复用的方法

1、判断浏览器是否支持某个原生类（函数）

```JavaScript
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}
```

