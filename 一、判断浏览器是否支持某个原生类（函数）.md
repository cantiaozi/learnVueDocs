## 一.new Vue()发生了什么

Vue函数定义在src\core\instance目录下的index.js文件中。

```JavaScript
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

_init方法src\core\instance目录下的init.js文件中。挂载在Vue的原型对象上。

```javascript
Vue.prototype._init = function (options?: Object) {
    ......
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    ......
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
```

_init方法中进行了一些列初始化操作，这里我们重点分析两个地方，Proxy代理和$mount页面挂载方法。

### 1.1Proxy代理

当我们在vue的template模板中使用了一个未定义的变量时，会报错提示。这是因为做了Proxy代理，当访问vue实例上的相应属性时，会通过这层代理。

![image-20210602203132025](E:\开发文档\新建文件夹\1)

initProxy是这样定义的。

```JavaScript
function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      const options = vm.$options
      const handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler
      vm._renderProxy = new Proxy(vm, handlers)
    } else {
      vm._renderProxy = vm
    }
}
```

其中hasProxy判断浏览器是否支持原生的Proxy对象。hasHander的定义如下。在hasHander对象中拦截了`propKey in proxy`的操作。warnNonPresent方法就是报错提示的方法。

```JavaScript
const hasHandler = {
    has (target, key) {
      const has = key in target
      const isAllowed = allowedGlobals(key) || (typeof key === 'string' && key.charAt(0) === '_')
      if (!has && !isAllowed) {
        warnNonPresent(target, key)
      }
      return has || !isAllowed
    }
}
```

```JavaScript
const warnNonPresent = (target, key) => {
    warn(
      `Property or method "${key}" is not defined on the instance but ` +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    )
}
```



## 一、可复用的方法

1、判断浏览器是否支持某个原生类（函数）

```JavaScript
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}
```

