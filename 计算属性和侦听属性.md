## 一、计算属性

在组件初始化的时候，调用initState方法中，不仅会对data、methods等属性初始化，也会对组件配置中的computed和watch属性进行初始化。对computed进行初始化，调用initComputed方法。

initComputed方法中，首先在vm实例上定义_computedWatchers属性，值为空对象。遍历computed属性中的每个对象（通常是一个函数，也可以是一个对象，但是必须具有get属性），对每个计算属性键值生成一个watcher实例，并储存在 vm实例的 _computedWatchers上，然后调用defineComputed方法将计算属性的键值映射到vm实例上，这样就可以直接在vm实例上以计算属性键key的方式访问相应的计算属性值。

```javascript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  ......
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}
```

```JavaScript
function initComputed (vm: Component, computed: Object) {
  // $flow-disable-line
  const watchers = vm._computedWatchers = Object.create(null)
  // computed properties are just getters during SSR
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' && getter == null) {
      warn(
        `Getter is missing for computed property "${key}".`,
        vm
      )
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    //当计算属性键已经存在于vm实例上时，说明已经在data或者props存在，报错。
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      }
    }
  }
}

const computedWatcherOptions = { computed: true }

export function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  //非服务端渲染，因此shouldCache为true
  const shouldCache = !isServerRendering()
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop
  }
  if (process.env.NODE_ENV !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property "${key}" was assigned to but it has no setter.`,
        this
      )
    }
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}

const sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
}

function createComputedGetter (key) {
  //当访问vm实例上的计算属性的键key，就会执行属性的get描述符,即下面的函数
  return function computedGetter () {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      watcher.depend()
      return watcher.evaluate()
    }
  }
}
```

现在来看看生成computed watcher实例过程中做了哪些事情。一开始computed watcher初始化的时候，并不会计算watcher实例的value值，而是将其赋值为undefined。当组件在渲染更新时，会访问vm实例上的计算属性的键key，就会执行属性的get描述符，拿到vm. _computedWatchers上相应key的watcher对象，调用watcher对象的depend方法，depend方法是专门为computed watcher服务的，在该方法中，computed watcher实例的dep对象调用depend方法，将渲染watcher收集到dep对象的subs属性上，最后调用watcher.evaluate()方法，在该方法中，执行get方法求值。

执行get方法，首先会将这个computed watcher赋给Dep.target，下面会执行这个computed watcher的getter方法，即计算属性自定义的函数，在执行这个函数的过程中，会访问其它的data属性或者其它计算属性，这样其它计算属性或者data属性的相应的dep对象就会收集这个computed watcher。当这个computed watcher依赖的data属性或者是其它计算属性值发生了改变后，就会通知这个computed watcher更新，执行update方法。computed watcher的update方法中，因为computed watcher的dep对象收集了渲染watcher，因此执行getAndInvoke方法，传入一个回调函数。getAndInvoke方法会重新对watcher进行求值，如果这次求的值和上次的值不相同的话，会将dirty置为false，并且去执行回调函数。回调函数中会去通知computed watcher的dep对象收集的watcher对象（包括渲染watcher和computed watcher）重新渲染。

```JavaScript
export default class Watcher {
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    //isRenderWatcher不存在，不执行if中的逻辑
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      ......
      //this.computed为true
      this.computed = !!options.computed
      ......
    } else {
      this.deep = this.user = this.computed = this.sync = false
    }
    ......
    this.dirty = this.computed // for computed watchers
    ......
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      //expOrFn就是computed中的函数
      this.getter = expOrFn
    } else {
      ......
    }
    if (this.computed) {
      //computed watcher初始的value为undefined
      this.value = undefined
      this.dep = new Dep()
    } else {
      this.value = this.get()
    }
  }
  /**
   * Depend on this watcher. Only for computed property watchers.
   */      
  depend () {
    if (this.dep && Dep.target) {
      this.dep.depend()
    }
  }
        
  /**
   * Evaluate and return the value of the watcher.
   * This only gets called for computed property watchers.
   */
  evaluate () {
    //第一次执行该方法时，dirty为true，走if的逻辑
    if (this.dirty) {
      this.value = this.get()
      this.dirty = false
    }
    return this.value
  }
  
  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  update () {
    /* istanbul ignore else */
    if (this.computed) {
      // A computed property watcher has two modes: lazy and activated.
      // It initializes as lazy by default, and only becomes activated when
      // it is depended on by at least one subscriber, which is typically
      // another computed property or a component's render function.
      if (this.dep.subs.length === 0) {
        // In lazy mode, we don't want to perform computations until necessary,
        // so we simply mark the watcher as dirty. The actual computation is
        // performed just-in-time in this.evaluate() when the computed property
        // is accessed.
        this.dirty = true
      } else {
        // In activated mode, we want to proactively perform the computation
        // but only notify our subscribers when the value has indeed changed.
        this.getAndInvoke(() => {
          this.dep.notify()
        })
      }
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
        
  getAndInvoke (cb: Function) {
    const value = this.get()
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      const oldValue = this.value
      this.value = value
      this.dirty = false
      if (this.user) {
        try {
          cb.call(this.vm, value, oldValue)
        } catch (e) {
          handleError(e, this.vm, `callback for watcher "${this.expression}"`)
        }
      } else {
        cb.call(this.vm, value, oldValue)
      }
    }
  }
}
```

